{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\nimport { BackgroundFetchResult, BackgroundFetchStatus } from \"./BackgroundFetch.types\";\nimport ExpoBackgroundFetch from \"./ExpoBackgroundFetch\";\nexport function getStatusAsync() {\n  return _getStatusAsync.apply(this, arguments);\n}\nfunction _getStatusAsync() {\n  _getStatusAsync = _asyncToGenerator(function* () {\n    if (Platform.OS === 'android') {\n      return BackgroundFetchStatus.Available;\n    }\n    return ExpoBackgroundFetch.getStatusAsync();\n  });\n  return _getStatusAsync.apply(this, arguments);\n}\nexport function setMinimumIntervalAsync(_x) {\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nfunction _setMinimumIntervalAsync() {\n  _setMinimumIntervalAsync = _asyncToGenerator(function* (minimumInterval) {\n    if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n      return;\n    }\n    yield ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n  });\n  return _setMinimumIntervalAsync.apply(this, arguments);\n}\nexport function registerTaskAsync(_x2) {\n  return _registerTaskAsync.apply(this, arguments);\n}\nfunction _registerTaskAsync() {\n  _registerTaskAsync = _asyncToGenerator(function* (taskName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ExpoBackgroundFetch.registerTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n    }\n    if (!TaskManager.isTaskDefined(taskName)) {\n      throw new Error(`Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`);\n    }\n    yield ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n  });\n  return _registerTaskAsync.apply(this, arguments);\n}\nexport function unregisterTaskAsync(_x3) {\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nfunction _unregisterTaskAsync() {\n  _unregisterTaskAsync = _asyncToGenerator(function* (taskName) {\n    if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n      throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n    }\n    yield ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n  });\n  return _unregisterTaskAsync.apply(this, arguments);\n}\nexport { BackgroundFetchResult, BackgroundFetchStatus };","map":{"version":3,"names":["Platform","UnavailabilityError","TaskManager","BackgroundFetchResult","BackgroundFetchStatus","ExpoBackgroundFetch","getStatusAsync","_getStatusAsync","apply","arguments","_asyncToGenerator","OS","Available","setMinimumIntervalAsync","_x","_setMinimumIntervalAsync","minimumInterval","registerTaskAsync","_x2","_registerTaskAsync","taskName","options","length","undefined","isTaskDefined","Error","unregisterTaskAsync","_x3","_unregisterTaskAsync"],"sources":["C:\\Users\\mohan\\OneDrive\\Desktop\\Mohan\\Microgrid app\\Microgrid-app\\node_modules\\expo-background-fetch\\src\\BackgroundFetch.ts"],"sourcesContent":["import { Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as TaskManager from 'expo-task-manager';\n\nimport {\n  BackgroundFetchOptions,\n  BackgroundFetchResult,\n  BackgroundFetchStatus,\n} from './BackgroundFetch.types';\nimport ExpoBackgroundFetch from './ExpoBackgroundFetch';\n\n// @needsAudit\n/**\n * Gets a status of background fetch.\n * @return Returns a promise which fulfils with one of `BackgroundFetchStatus` enum values.\n */\nexport async function getStatusAsync(): Promise<BackgroundFetchStatus | null> {\n  if (Platform.OS === 'android') {\n    return BackgroundFetchStatus.Available;\n  }\n  return ExpoBackgroundFetch.getStatusAsync();\n}\n\n// @needsAudit\n/**\n * Sets the minimum number of seconds that must elapse before another background fetch can be\n * initiated. This value is advisory only and does not indicate the exact amount of time expected\n * between fetch operations.\n *\n * > This method doesn't take any effect on Android. It is a global value which means that it can\n * overwrite settings from another application opened through Expo Go.\n *\n * @param minimumInterval Number of seconds that must elapse before another background fetch can be called.\n * @return A promise which fulfils once the minimum interval is set.\n */\nexport async function setMinimumIntervalAsync(minimumInterval: number): Promise<void> {\n  if (!ExpoBackgroundFetch.setMinimumIntervalAsync) {\n    return;\n  }\n  // iOS only\n  await ExpoBackgroundFetch.setMinimumIntervalAsync(minimumInterval);\n}\n\n// @needsAudit\n/**\n * Registers background fetch task with given name. Registered tasks are saved in persistent storage and restored once the app is initialized.\n * @param taskName Name of the task to register. The task needs to be defined first - see [`TaskManager.defineTask`](taskmanager#defineTask)\n * for more details.\n * @param options An object containing the background fetch options.\n *\n * @example\n * ```ts\n * import * as BackgroundFetch from 'expo-background-fetch';\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, () => {\n *   try {\n *     const receivedNewData = // do your background fetch here\n *     return receivedNewData ? BackgroundFetch.BackgroundFetchResult.NewData : BackgroundFetch.BackgroundFetchResult.NoData;\n *   } catch (error) {\n *     return BackgroundFetch.BackgroundFetchResult.Failed;\n *   }\n * });\n * ```\n */\nexport async function registerTaskAsync(\n  taskName: string,\n  options: BackgroundFetchOptions = {}\n): Promise<void> {\n  if (!ExpoBackgroundFetch.registerTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'registerTaskAsync');\n  }\n  if (!TaskManager.isTaskDefined(taskName)) {\n    throw new Error(\n      `Task '${taskName}' is not defined. You must define a task using TaskManager.defineTask before registering.`\n    );\n  }\n  await ExpoBackgroundFetch.registerTaskAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Unregisters background fetch task, so the application will no longer be executing this task.\n * @param taskName Name of the task to unregister.\n * @return A promise which fulfils when the task is fully unregistered.\n */\nexport async function unregisterTaskAsync(taskName: string): Promise<void> {\n  if (!ExpoBackgroundFetch.unregisterTaskAsync) {\n    throw new UnavailabilityError('BackgroundFetch', 'unregisterTaskAsync');\n  }\n  await ExpoBackgroundFetch.unregisterTaskAsync(taskName);\n}\n\nexport { BackgroundFetchResult, BackgroundFetchStatus, BackgroundFetchOptions };\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,mBAAmB,QAAQ,mBAAmB;AACjE,OAAO,KAAKC,WAAW,MAAM,mBAAmB;AAEhD,SAEEC,qBAAqB,EACrBC,qBAAqB;AAEvB,OAAOC,mBAAmB;AAO1B,gBAAsBC,cAAcA,CAAA;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAKnC,SAAAF,gBAAA;EAAAA,eAAA,GAAAG,iBAAA,CALM,aAA6B;IAClC,IAAIV,QAAQ,CAACW,EAAE,KAAK,SAAS,EAAE;MAC7B,OAAOP,qBAAqB,CAACQ,SAAS;;IAExC,OAAOP,mBAAmB,CAACC,cAAc,EAAE;EAC7C,CAAC;EAAA,OAAAC,eAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAcD,gBAAsBI,uBAAuBA,CAAAC,EAAA;EAAA,OAAAC,wBAAA,CAAAP,KAAA,OAAAC,SAAA;AAAA;AAM5C,SAAAM,yBAAA;EAAAA,wBAAA,GAAAL,iBAAA,CANM,WAAuCM,eAAuB;IACnE,IAAI,CAACX,mBAAmB,CAACQ,uBAAuB,EAAE;MAChD;;IAGF,MAAMR,mBAAmB,CAACQ,uBAAuB,CAACG,eAAe,CAAC;EACpE,CAAC;EAAA,OAAAD,wBAAA,CAAAP,KAAA,OAAAC,SAAA;AAAA;AAwBD,gBAAsBQ,iBAAiBA,CAAAC,GAAA;EAAA,OAAAC,kBAAA,CAAAX,KAAA,OAAAC,SAAA;AAAA;AAatC,SAAAU,mBAAA;EAAAA,kBAAA,GAAAT,iBAAA,CAbM,WACLU,QAAgB,EACoB;IAAA,IAApCC,OAAA,GAAAZ,SAAA,CAAAa,MAAA,QAAAb,SAAA,QAAAc,SAAA,GAAAd,SAAA,MAAkC,EAAE;IAEpC,IAAI,CAACJ,mBAAmB,CAACY,iBAAiB,EAAE;MAC1C,MAAM,IAAIhB,mBAAmB,CAAC,iBAAiB,EAAE,mBAAmB,CAAC;;IAEvE,IAAI,CAACC,WAAW,CAACsB,aAAa,CAACJ,QAAQ,CAAC,EAAE;MACxC,MAAM,IAAIK,KAAK,CACb,SAASL,QAAQ,2FAA2F,CAC7G;;IAEH,MAAMf,mBAAmB,CAACY,iBAAiB,CAACG,QAAQ,EAAEC,OAAO,CAAC;EAChE,CAAC;EAAA,OAAAF,kBAAA,CAAAX,KAAA,OAAAC,SAAA;AAAA;AAQD,gBAAsBiB,mBAAmBA,CAAAC,GAAA;EAAA,OAAAC,oBAAA,CAAApB,KAAA,OAAAC,SAAA;AAAA;AAKxC,SAAAmB,qBAAA;EAAAA,oBAAA,GAAAlB,iBAAA,CALM,WAAmCU,QAAgB;IACxD,IAAI,CAACf,mBAAmB,CAACqB,mBAAmB,EAAE;MAC5C,MAAM,IAAIzB,mBAAmB,CAAC,iBAAiB,EAAE,qBAAqB,CAAC;;IAEzE,MAAMI,mBAAmB,CAACqB,mBAAmB,CAACN,QAAQ,CAAC;EACzD,CAAC;EAAA,OAAAQ,oBAAA,CAAApB,KAAA,OAAAC,SAAA;AAAA;AAED,SAASN,qBAAqB,EAAEC,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}