{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar DB_CONFIG = {\n  host: '192.168.43.147',\n  port: 5432,\n  database: 'microgrid_db',\n  tables: {\n    meter: 'meter_data',\n    solar: 'solar_data'\n  },\n  columns: {\n    meter: {\n      timestamp: 'time',\n      id: 'meter_id',\n      voltage: 'voltage',\n      current: 'current',\n      power: 'power',\n      energy: 'energy',\n      pf: 'pf',\n      frequency: 'frequency'\n    },\n    solar: {\n      timestamp: 'time',\n      id: 'panel_id',\n      voltage: 'voltage',\n      current: 'current',\n      power: 'power'\n    }\n  }\n};\nvar API_BASE_URL = 'http://192.168.43.147:3001';\nvar AnalyticsService = function () {\n  function AnalyticsService() {\n    _classCallCheck(this, AnalyticsService);\n    this.isConnected = false;\n  }\n  return _createClass(AnalyticsService, [{\n    key: \"formatDateForQuery\",\n    value: function formatDateForQuery(date) {\n      var year = date.getFullYear();\n      var month = String(date.getMonth() + 1).padStart(2, '0');\n      var day = String(date.getDate()).padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    }\n  }, {\n    key: \"getTableName\",\n    value: function getTableName(sourceType) {\n      return sourceType === 'Meter' ? DB_CONFIG.tables.meter : DB_CONFIG.tables.solar;\n    }\n  }, {\n    key: \"fetchAnalyticsData\",\n    value: function () {\n      var _fetchAnalyticsData = _asyncToGenerator(function* (sourceType, subOption, fromDate, toDate) {\n        try {\n          var tableName = this.getTableName(sourceType);\n          var fromDateStr = this.formatDateForQuery(fromDate);\n          var toDateStr = this.formatDateForQuery(toDate);\n          var filterValue;\n          if (sourceType === 'Meter') {\n            filterValue = subOption.replace('Line ', '');\n          } else {\n            filterValue = subOption.replace('Panel ', '');\n          }\n          var response = yield fetch(`${API_BASE_URL}/api/analytics`, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              table: tableName,\n              sourceType: sourceType,\n              filterColumn: sourceType === 'Meter' ? 'meter_id' : 'panel_id',\n              filterValue: filterValue,\n              fromDate: fromDateStr,\n              toDate: toDateStr\n            })\n          });\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          var data = yield response.json();\n          return {\n            success: true,\n            data: data,\n            message: 'Data fetched successfully'\n          };\n        } catch (error) {\n          console.error('Error fetching analytics data:', error);\n          return {\n            success: false,\n            data: null,\n            message: error.message || 'Failed to fetch data'\n          };\n        }\n      });\n      function fetchAnalyticsData(_x, _x2, _x3, _x4) {\n        return _fetchAnalyticsData.apply(this, arguments);\n      }\n      return fetchAnalyticsData;\n    }()\n  }, {\n    key: \"processDataForChart\",\n    value: function processDataForChart(rawData, sourceType) {\n      if (!rawData || rawData.length === 0) {\n        return {\n          labels: [],\n          values: [],\n          stats: {\n            peak: 0,\n            average: 0,\n            total: 0,\n            min: 0\n          }\n        };\n      }\n      var groupedData = {};\n      rawData.forEach(function (item) {\n        var date = new Date(item.time);\n        var dateKey = date.toLocaleDateString('en-US', {\n          month: 'short',\n          day: 'numeric'\n        });\n        if (!groupedData[dateKey]) {\n          groupedData[dateKey] = {\n            values: [],\n            count: 0\n          };\n        }\n        var value = parseFloat(item.power) || 0;\n        groupedData[dateKey].values.push(value);\n        groupedData[dateKey].count++;\n      });\n      var labels = Object.keys(groupedData).slice(-7);\n      var values = labels.map(function (label) {\n        var group = groupedData[label];\n        return group.values.reduce(function (a, b) {\n          return a + b;\n        }, 0) / group.count;\n      });\n      var allValues = rawData.map(function (item) {\n        return parseFloat(item.power) || 0;\n      }).filter(function (v) {\n        return v > 0;\n      });\n      var stats = {\n        peak: allValues.length > 0 ? Math.max.apply(Math, _toConsumableArray(allValues)) : 0,\n        min: allValues.length > 0 ? Math.min.apply(Math, _toConsumableArray(allValues)) : 0,\n        average: allValues.length > 0 ? allValues.reduce(function (a, b) {\n          return a + b;\n        }, 0) / allValues.length : 0,\n        total: allValues.reduce(function (a, b) {\n          return a + b;\n        }, 0)\n      };\n      return {\n        labels: labels,\n        values: values,\n        stats: stats\n      };\n    }\n  }, {\n    key: \"generateSampleData\",\n    value: function generateSampleData(sourceType, subOption, fromDate, toDate) {\n      var days = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)) + 1;\n      var dataPoints = Math.min(days, 7);\n      var labels = [];\n      var values = [];\n      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n      for (var i = 0; i < dataPoints; i++) {\n        var date = new Date(fromDate);\n        date.setDate(date.getDate() + i);\n        labels.push(`${months[date.getMonth()]} ${date.getDate()}`);\n        if (sourceType === 'Meter') {\n          values.push(Math.floor(Math.random() * 1500) + 500);\n        } else {\n          values.push(Math.floor(Math.random() * 1000) + 200);\n        }\n      }\n      var stats = {\n        peak: Math.max.apply(Math, values),\n        min: Math.min.apply(Math, values),\n        average: Math.round(values.reduce(function (a, b) {\n          return a + b;\n        }, 0) / values.length),\n        total: values.reduce(function (a, b) {\n          return a + b;\n        }, 0)\n      };\n      return {\n        labels: labels,\n        values: values,\n        stats: stats\n      };\n    }\n  }]);\n}();\nexport default new AnalyticsService();","map":{"version":3,"names":["DB_CONFIG","host","port","database","tables","meter","solar","columns","timestamp","id","voltage","current","power","energy","pf","frequency","API_BASE_URL","AnalyticsService","_classCallCheck","isConnected","_createClass","key","value","formatDateForQuery","date","year","getFullYear","month","String","getMonth","padStart","day","getDate","getTableName","sourceType","_fetchAnalyticsData","_asyncToGenerator","subOption","fromDate","toDate","tableName","fromDateStr","toDateStr","filterValue","replace","response","fetch","method","headers","body","JSON","stringify","table","filterColumn","ok","Error","status","data","json","success","message","error","console","fetchAnalyticsData","_x","_x2","_x3","_x4","apply","arguments","processDataForChart","rawData","length","labels","values","stats","peak","average","total","min","groupedData","forEach","item","Date","time","dateKey","toLocaleDateString","count","parseFloat","push","Object","keys","slice","map","label","group","reduce","a","b","allValues","filter","v","Math","max","_toConsumableArray","generateSampleData","days","ceil","dataPoints","months","i","setDate","floor","random","round"],"sources":["C:/Users/mohan/OneDrive/Desktop/Mohan/Microgrid app/src/services/AnalyticsService.js"],"sourcesContent":["// Analytics Service - Handles database queries for analytics data\r\n// This service connects to the PostgreSQL database and fetches meter/solar data\r\n\r\n// Database configuration (matching database.js)\r\nconst DB_CONFIG = {\r\n  host: '192.168.43.147',\r\n  port: 5432,\r\n  database: 'microgrid_db',\r\n  tables: {\r\n    meter: 'meter_data',\r\n    solar: 'solar_data'\r\n  },\r\n  // Actual column names from database\r\n  columns: {\r\n    meter: {\r\n      timestamp: 'time',\r\n      id: 'meter_id',\r\n      voltage: 'voltage',\r\n      current: 'current',\r\n      power: 'power',\r\n      energy: 'energy',\r\n      pf: 'pf',\r\n      frequency: 'frequency'\r\n    },\r\n    solar: {\r\n      timestamp: 'time',\r\n      id: 'panel_id',\r\n      voltage: 'voltage',\r\n      current: 'current',\r\n      power: 'power'\r\n    }\r\n  }\r\n};\r\n\r\n// API Base URL - Update this to your backend server URL\r\nconst API_BASE_URL = 'http://192.168.43.147:3001';\r\n\r\nclass AnalyticsService {\r\n  constructor() {\r\n    this.isConnected = false;\r\n  }\r\n\r\n  // Format date for PostgreSQL query\r\n  formatDateForQuery(date) {\r\n    const year = date.getFullYear();\r\n    const month = String(date.getMonth() + 1).padStart(2, '0');\r\n    const day = String(date.getDate()).padStart(2, '0');\r\n    return `${year}-${month}-${day}`;\r\n  }\r\n\r\n  // Get table name based on source type\r\n  getTableName(sourceType) {\r\n    return sourceType === 'Meter' ? DB_CONFIG.tables.meter : DB_CONFIG.tables.solar;\r\n  }\r\n\r\n  // Fetch analytics data from the backend\r\n  async fetchAnalyticsData(sourceType, subOption, fromDate, toDate) {\r\n    try {\r\n      const tableName = this.getTableName(sourceType);\r\n      const fromDateStr = this.formatDateForQuery(fromDate);\r\n      const toDateStr = this.formatDateForQuery(toDate);\r\n\r\n      // Determine the line/panel filter value\r\n      let filterValue;\r\n      if (sourceType === 'Meter') {\r\n        // Extract line number from \"Line 1\", \"Line 2\", \"Line 3\"\r\n        filterValue = subOption.replace('Line ', '');\r\n      } else {\r\n        // Extract panel number from \"Panel 1\", \"Panel 2\"\r\n        filterValue = subOption.replace('Panel ', '');\r\n      }\r\n\r\n      const response = await fetch(`${API_BASE_URL}/api/analytics`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          table: tableName,\r\n          sourceType: sourceType,\r\n          filterColumn: sourceType === 'Meter' ? 'meter_id' : 'panel_id',\r\n          filterValue: filterValue,\r\n          fromDate: fromDateStr,\r\n          toDate: toDateStr,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n\r\n      const data = await response.json();\r\n      return {\r\n        success: true,\r\n        data: data,\r\n        message: 'Data fetched successfully'\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching analytics data:', error);\r\n      return {\r\n        success: false,\r\n        data: null,\r\n        message: error.message || 'Failed to fetch data'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Process raw data for chart display\r\n  processDataForChart(rawData, sourceType) {\r\n    if (!rawData || rawData.length === 0) {\r\n      return {\r\n        labels: [],\r\n        values: [],\r\n        stats: { peak: 0, average: 0, total: 0, min: 0 }\r\n      };\r\n    }\r\n\r\n    // Group data by date and calculate daily averages\r\n    const groupedData = {};\r\n    \r\n    rawData.forEach(item => {\r\n      // Use 'time' column which is the actual timestamp column in both tables\r\n      const date = new Date(item.time);\r\n      const dateKey = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\r\n      \r\n      if (!groupedData[dateKey]) {\r\n        groupedData[dateKey] = { values: [], count: 0 };\r\n      }\r\n      \r\n      // Get the power value - 'power' column exists in both meter_data and solar_data\r\n      const value = parseFloat(item.power) || 0;\r\n      \r\n      groupedData[dateKey].values.push(value);\r\n      groupedData[dateKey].count++;\r\n    });\r\n\r\n    // Calculate averages for each date\r\n    const labels = Object.keys(groupedData).slice(-7); // Last 7 data points\r\n    const values = labels.map(label => {\r\n      const group = groupedData[label];\r\n      return group.values.reduce((a, b) => a + b, 0) / group.count;\r\n    });\r\n\r\n    // Calculate statistics using 'power' column from both tables\r\n    const allValues = rawData.map(item => {\r\n      return parseFloat(item.power) || 0;\r\n    }).filter(v => v > 0);\r\n\r\n    const stats = {\r\n      peak: allValues.length > 0 ? Math.max(...allValues) : 0,\r\n      min: allValues.length > 0 ? Math.min(...allValues) : 0,\r\n      average: allValues.length > 0 ? allValues.reduce((a, b) => a + b, 0) / allValues.length : 0,\r\n      total: allValues.reduce((a, b) => a + b, 0)\r\n    };\r\n\r\n    return { labels, values, stats };\r\n  }\r\n\r\n  // Generate sample data for testing (when database is not available)\r\n  generateSampleData(sourceType, subOption, fromDate, toDate) {\r\n    const days = Math.ceil((toDate - fromDate) / (1000 * 60 * 60 * 24)) + 1;\r\n    const dataPoints = Math.min(days, 7);\r\n    \r\n    const labels = [];\r\n    const values = [];\r\n    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\r\n    \r\n    for (let i = 0; i < dataPoints; i++) {\r\n      const date = new Date(fromDate);\r\n      date.setDate(date.getDate() + i);\r\n      labels.push(`${months[date.getMonth()]} ${date.getDate()}`);\r\n      \r\n      // Generate realistic values based on source type\r\n      if (sourceType === 'Meter') {\r\n        // Meter power in Watts (500-2000W range)\r\n        values.push(Math.floor(Math.random() * 1500) + 500);\r\n      } else {\r\n        // Solar power in Watts (200-1200W range, peak during midday)\r\n        values.push(Math.floor(Math.random() * 1000) + 200);\r\n      }\r\n    }\r\n\r\n    const stats = {\r\n      peak: Math.max(...values),\r\n      min: Math.min(...values),\r\n      average: Math.round(values.reduce((a, b) => a + b, 0) / values.length),\r\n      total: values.reduce((a, b) => a + b, 0)\r\n    };\r\n\r\n    return { labels, values, stats };\r\n  }\r\n}\r\n\r\nexport default new AnalyticsService();\r\n"],"mappings":";;;;AAIA,IAAMA,SAAS,GAAG;EAChBC,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAE,IAAI;EACVC,QAAQ,EAAE,cAAc;EACxBC,MAAM,EAAE;IACNC,KAAK,EAAE,YAAY;IACnBC,KAAK,EAAE;EACT,CAAC;EAEDC,OAAO,EAAE;IACPF,KAAK,EAAE;MACLG,SAAS,EAAE,MAAM;MACjBC,EAAE,EAAE,UAAU;MACdC,OAAO,EAAE,SAAS;MAClBC,OAAO,EAAE,SAAS;MAClBC,KAAK,EAAE,OAAO;MACdC,MAAM,EAAE,QAAQ;MAChBC,EAAE,EAAE,IAAI;MACRC,SAAS,EAAE;IACb,CAAC;IACDT,KAAK,EAAE;MACLE,SAAS,EAAE,MAAM;MACjBC,EAAE,EAAE,UAAU;MACdC,OAAO,EAAE,SAAS;MAClBC,OAAO,EAAE,SAAS;MAClBC,KAAK,EAAE;IACT;EACF;AACF,CAAC;AAGD,IAAMI,YAAY,GAAG,4BAA4B;AAAC,IAE5CC,gBAAgB;EACpB,SAAAA,iBAAA,EAAc;IAAAC,eAAA,OAAAD,gBAAA;IACZ,IAAI,CAACE,WAAW,GAAG,KAAK;EAC1B;EAAC,OAAAC,YAAA,CAAAH,gBAAA;IAAAI,GAAA;IAAAC,KAAA,EAGD,SAAAC,kBAAkBA,CAACC,IAAI,EAAE;MACvB,IAAMC,IAAI,GAAGD,IAAI,CAACE,WAAW,CAAC,CAAC;MAC/B,IAAMC,KAAK,GAAGC,MAAM,CAACJ,IAAI,CAACK,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MAC1D,IAAMC,GAAG,GAAGH,MAAM,CAACJ,IAAI,CAACQ,OAAO,CAAC,CAAC,CAAC,CAACF,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;MACnD,OAAO,GAAGL,IAAI,IAAIE,KAAK,IAAII,GAAG,EAAE;IAClC;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAGD,SAAAW,YAAYA,CAACC,UAAU,EAAE;MACvB,OAAOA,UAAU,KAAK,OAAO,GAAGlC,SAAS,CAACI,MAAM,CAACC,KAAK,GAAGL,SAAS,CAACI,MAAM,CAACE,KAAK;IACjF;EAAC;IAAAe,GAAA;IAAAC,KAAA;MAAA,IAAAa,mBAAA,GAAAC,iBAAA,CAGD,WAAyBF,UAAU,EAAEG,SAAS,EAAEC,QAAQ,EAAEC,MAAM,EAAE;QAChE,IAAI;UACF,IAAMC,SAAS,GAAG,IAAI,CAACP,YAAY,CAACC,UAAU,CAAC;UAC/C,IAAMO,WAAW,GAAG,IAAI,CAAClB,kBAAkB,CAACe,QAAQ,CAAC;UACrD,IAAMI,SAAS,GAAG,IAAI,CAACnB,kBAAkB,CAACgB,MAAM,CAAC;UAGjD,IAAII,WAAW;UACf,IAAIT,UAAU,KAAK,OAAO,EAAE;YAE1BS,WAAW,GAAGN,SAAS,CAACO,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;UAC9C,CAAC,MAAM;YAELD,WAAW,GAAGN,SAAS,CAACO,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;UAC/C;UAEA,IAAMC,QAAQ,SAASC,KAAK,CAAC,GAAG9B,YAAY,gBAAgB,EAAE;YAC5D+B,MAAM,EAAE,MAAM;YACdC,OAAO,EAAE;cACP,cAAc,EAAE;YAClB,CAAC;YACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;cACnBC,KAAK,EAAEZ,SAAS;cAChBN,UAAU,EAAEA,UAAU;cACtBmB,YAAY,EAAEnB,UAAU,KAAK,OAAO,GAAG,UAAU,GAAG,UAAU;cAC9DS,WAAW,EAAEA,WAAW;cACxBL,QAAQ,EAAEG,WAAW;cACrBF,MAAM,EAAEG;YACV,CAAC;UACH,CAAC,CAAC;UAEF,IAAI,CAACG,QAAQ,CAACS,EAAE,EAAE;YAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuBV,QAAQ,CAACW,MAAM,EAAE,CAAC;UAC3D;UAEA,IAAMC,IAAI,SAASZ,QAAQ,CAACa,IAAI,CAAC,CAAC;UAClC,OAAO;YACLC,OAAO,EAAE,IAAI;YACbF,IAAI,EAAEA,IAAI;YACVG,OAAO,EAAE;UACX,CAAC;QACH,CAAC,CAAC,OAAOC,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;UACtD,OAAO;YACLF,OAAO,EAAE,KAAK;YACdF,IAAI,EAAE,IAAI;YACVG,OAAO,EAAEC,KAAK,CAACD,OAAO,IAAI;UAC5B,CAAC;QACH;MACF,CAAC;MAAA,SAjDKG,kBAAkBA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAhC,mBAAA,CAAAiC,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAlBN,kBAAkB;IAAA;EAAA;IAAA1C,GAAA;IAAAC,KAAA,EAoDxB,SAAAgD,mBAAmBA,CAACC,OAAO,EAAErC,UAAU,EAAE;MACvC,IAAI,CAACqC,OAAO,IAAIA,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE;QACpC,OAAO;UACLC,MAAM,EAAE,EAAE;UACVC,MAAM,EAAE,EAAE;UACVC,KAAK,EAAE;YAAEC,IAAI,EAAE,CAAC;YAAEC,OAAO,EAAE,CAAC;YAAEC,KAAK,EAAE,CAAC;YAAEC,GAAG,EAAE;UAAE;QACjD,CAAC;MACH;MAGA,IAAMC,WAAW,GAAG,CAAC,CAAC;MAEtBT,OAAO,CAACU,OAAO,CAAC,UAAAC,IAAI,EAAI;QAEtB,IAAM1D,IAAI,GAAG,IAAI2D,IAAI,CAACD,IAAI,CAACE,IAAI,CAAC;QAChC,IAAMC,OAAO,GAAG7D,IAAI,CAAC8D,kBAAkB,CAAC,OAAO,EAAE;UAAE3D,KAAK,EAAE,OAAO;UAAEI,GAAG,EAAE;QAAU,CAAC,CAAC;QAEpF,IAAI,CAACiD,WAAW,CAACK,OAAO,CAAC,EAAE;UACzBL,WAAW,CAACK,OAAO,CAAC,GAAG;YAAEX,MAAM,EAAE,EAAE;YAAEa,KAAK,EAAE;UAAE,CAAC;QACjD;QAGA,IAAMjE,KAAK,GAAGkE,UAAU,CAACN,IAAI,CAACtE,KAAK,CAAC,IAAI,CAAC;QAEzCoE,WAAW,CAACK,OAAO,CAAC,CAACX,MAAM,CAACe,IAAI,CAACnE,KAAK,CAAC;QACvC0D,WAAW,CAACK,OAAO,CAAC,CAACE,KAAK,EAAE;MAC9B,CAAC,CAAC;MAGF,IAAMd,MAAM,GAAGiB,MAAM,CAACC,IAAI,CAACX,WAAW,CAAC,CAACY,KAAK,CAAC,CAAC,CAAC,CAAC;MACjD,IAAMlB,MAAM,GAAGD,MAAM,CAACoB,GAAG,CAAC,UAAAC,KAAK,EAAI;QACjC,IAAMC,KAAK,GAAGf,WAAW,CAACc,KAAK,CAAC;QAChC,OAAOC,KAAK,CAACrB,MAAM,CAACsB,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,GAAGC,CAAC;QAAA,GAAE,CAAC,CAAC,GAAGH,KAAK,CAACR,KAAK;MAC9D,CAAC,CAAC;MAGF,IAAMY,SAAS,GAAG5B,OAAO,CAACsB,GAAG,CAAC,UAAAX,IAAI,EAAI;QACpC,OAAOM,UAAU,CAACN,IAAI,CAACtE,KAAK,CAAC,IAAI,CAAC;MACpC,CAAC,CAAC,CAACwF,MAAM,CAAC,UAAAC,CAAC;QAAA,OAAIA,CAAC,GAAG,CAAC;MAAA,EAAC;MAErB,IAAM1B,KAAK,GAAG;QACZC,IAAI,EAAEuB,SAAS,CAAC3B,MAAM,GAAG,CAAC,GAAG8B,IAAI,CAACC,GAAG,CAAAnC,KAAA,CAARkC,IAAI,EAAAE,kBAAA,CAAQL,SAAS,EAAC,GAAG,CAAC;QACvDpB,GAAG,EAAEoB,SAAS,CAAC3B,MAAM,GAAG,CAAC,GAAG8B,IAAI,CAACvB,GAAG,CAAAX,KAAA,CAARkC,IAAI,EAAAE,kBAAA,CAAQL,SAAS,EAAC,GAAG,CAAC;QACtDtB,OAAO,EAAEsB,SAAS,CAAC3B,MAAM,GAAG,CAAC,GAAG2B,SAAS,CAACH,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,GAAGC,CAAC;QAAA,GAAE,CAAC,CAAC,GAAGC,SAAS,CAAC3B,MAAM,GAAG,CAAC;QAC3FM,KAAK,EAAEqB,SAAS,CAACH,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,GAAGC,CAAC;QAAA,GAAE,CAAC;MAC5C,CAAC;MAED,OAAO;QAAEzB,MAAM,EAANA,MAAM;QAAEC,MAAM,EAANA,MAAM;QAAEC,KAAK,EAALA;MAAM,CAAC;IAClC;EAAC;IAAAtD,GAAA;IAAAC,KAAA,EAGD,SAAAmF,kBAAkBA,CAACvE,UAAU,EAAEG,SAAS,EAAEC,QAAQ,EAAEC,MAAM,EAAE;MAC1D,IAAMmE,IAAI,GAAGJ,IAAI,CAACK,IAAI,CAAC,CAACpE,MAAM,GAAGD,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC;MACvE,IAAMsE,UAAU,GAAGN,IAAI,CAACvB,GAAG,CAAC2B,IAAI,EAAE,CAAC,CAAC;MAEpC,IAAMjC,MAAM,GAAG,EAAE;MACjB,IAAMC,MAAM,GAAG,EAAE;MACjB,IAAMmC,MAAM,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;MAEnG,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,EAAEE,CAAC,EAAE,EAAE;QACnC,IAAMtF,IAAI,GAAG,IAAI2D,IAAI,CAAC7C,QAAQ,CAAC;QAC/Bd,IAAI,CAACuF,OAAO,CAACvF,IAAI,CAACQ,OAAO,CAAC,CAAC,GAAG8E,CAAC,CAAC;QAChCrC,MAAM,CAACgB,IAAI,CAAC,GAAGoB,MAAM,CAACrF,IAAI,CAACK,QAAQ,CAAC,CAAC,CAAC,IAAIL,IAAI,CAACQ,OAAO,CAAC,CAAC,EAAE,CAAC;QAG3D,IAAIE,UAAU,KAAK,OAAO,EAAE;UAE1BwC,MAAM,CAACe,IAAI,CAACa,IAAI,CAACU,KAAK,CAACV,IAAI,CAACW,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC;QACrD,CAAC,MAAM;UAELvC,MAAM,CAACe,IAAI,CAACa,IAAI,CAACU,KAAK,CAACV,IAAI,CAACW,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC;QACrD;MACF;MAEA,IAAMtC,KAAK,GAAG;QACZC,IAAI,EAAE0B,IAAI,CAACC,GAAG,CAAAnC,KAAA,CAARkC,IAAI,EAAQ5B,MAAM,CAAC;QACzBK,GAAG,EAAEuB,IAAI,CAACvB,GAAG,CAAAX,KAAA,CAARkC,IAAI,EAAQ5B,MAAM,CAAC;QACxBG,OAAO,EAAEyB,IAAI,CAACY,KAAK,CAACxC,MAAM,CAACsB,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,GAAGC,CAAC;QAAA,GAAE,CAAC,CAAC,GAAGxB,MAAM,CAACF,MAAM,CAAC;QACtEM,KAAK,EAAEJ,MAAM,CAACsB,MAAM,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,GAAGC,CAAC;QAAA,GAAE,CAAC;MACzC,CAAC;MAED,OAAO;QAAEzB,MAAM,EAANA,MAAM;QAAEC,MAAM,EAANA,MAAM;QAAEC,KAAK,EAALA;MAAM,CAAC;IAClC;EAAC;AAAA;AAGH,eAAe,IAAI1D,gBAAgB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}